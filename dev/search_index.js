var documenterSearchIndex = {"docs":
[{"location":"manual/codegen/#man_codegen","page":"Code generation","title":"Code Generation","text":"","category":"section"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"Allocation free\nShow basic file structure, \nHow to call code ","category":"page"},{"location":"manual/prestab_moveblock/#man_prestabl_moveblock","page":"Prestabilization & Move blocking ","title":"Prestabilization & Move Blocking","text":"","category":"section"},{"location":"manual/prestab_moveblock/","page":"Prestabilization & Move blocking ","title":"Prestabilization & Move blocking ","text":"Prestabilizing \nMove blocking","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#LinearMPC.add_constraint!-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.add_constraint!","text":"add_constraint!(mpc::MPC;\n    Ax, Au, Ar, Aw, Ad, Aup,\n    ub, lb, ks, soft, binary, prio)\nadd_constraint!(mpc;Ax,Au,ub,lb,\n                ks, soft, binary,prio)\n\nAdds the constraints lb ≤ Ax xₖ + Au uₖ ≤ ub for the time steps k ∈ ks (additional terms Ar rₖ, Aw wₖ, Ad dₖ, Aup u⁻ₖ are possible)\n\nsoft marks if the constraint should be softened (default false)\nbinary marks if either the upper or lower bounds should be enforced with equality (default false)\nprio marks the relative priority of the constraint (default 0)\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.certify-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.certify","text":"certify(mpc; range, AS0, opts)\n\nProvide certificates on the iteration complexity of DAQP for solving the resulting optimization problems. \n\nrange is the parameter range over which the certification should be done\nAS0 is the starting working set in DAQP (defaults to empty)\nsettings the settings used in the certification (see ASCertain.CertSettings()) \n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.compute_control-Tuple{Union{LinearMPC.ExplicitMPC, LinearMPC.MPC}, Any}","page":"Functions","title":"LinearMPC.compute_control","text":"compute_control(mpc,x;r,uprev)\n\nFor a given MPC mpc and state x, compute the optimal control action.  Optional arguments: \n\nr - reference value\nuprev - previous control action\n\nall of them defaults to zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.move_block!-Tuple{Any, Vector{Int64}}","page":"Functions","title":"LinearMPC.move_block!","text":"move_block!(mpc,block)\n\nReduce the number of controls by keeping it constant in blocks. For example, block=[2,1,3] keeps the control constant for 2 time-steps, 1 time step, and 3 time steps.\n\nif sum(block) ≠ mpc.Nc, the resulting block will be padded or clipped\nif block is an Int, a vector with constant block size is created\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.mpc2mpqp-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.mpc2mpqp","text":"mpc2mpqp(mpc)\n\nFor a given MPC structure mpc, form the multi-parametric QP mpQP. \n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_bounds!-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.set_bounds!","text":"set_bounds!(mpc;umin,umax)\n\nSets the bounds umin ≤ u ≤ umax \n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_labels!-Tuple{Any}","page":"Functions","title":"LinearMPC.set_labels!","text":"set_labels!(mpc;x,u,y,d)\n\nSets the name of the states x, controls u, output u, disturbance d \n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_output_bounds!-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.set_output_bounds!","text":"set_output_bounds!(mpc;ymin,ymax,\n                ks, soft, binary,prio)\n\nAdds the constraints lb ≤ C x  ≤ ub for the time steps k ∈ ks \n\nsoft marks if the constraint should be softened (default false)\nbinary marks if either the upper or lower bounds should be enforced with equality (default false)\nprio marks the relative priority of the constraint (default 0)\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_prestabilizing_feedback!-Tuple{Any, AbstractMatrix}","page":"Functions","title":"LinearMPC.set_prestabilizing_feedback!","text":"set_prestabilizing_feedback!(mpc,K)\n\nSets the prestabilizing feedback K\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_prestabilizing_feedback!-Tuple{Any}","page":"Functions","title":"LinearMPC.set_prestabilizing_feedback!","text":"set_prestabilizing_feedback!(mpc)\n\nSets the prestabilizing feedback K to the infinte horizon LQR gain`\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_terminal_cost!-Tuple{Any}","page":"Functions","title":"LinearMPC.set_terminal_cost!","text":"set_terminal_cost!(mpc)\n\nSets the terminal cost Qf to the inifinite horizon LQR cost \n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.set_weights!-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.set_weights!","text":"set_weights!(mpc;Q,R,Rr,S,Qf)\n\nThe weights in the objective function `xN' Qf xN^T + ∑ (C xₖ - rₖ)' Q (C xₖ - rₖ)  + uₖ' R uₖ + Δuₖ' Rr Δuₖ + xₖ' S uₖ \n\nA vector is interpreted as a diagonal matrix.\n\nrho Is an additional weight for the soft constraints (default value: 1e6)\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearMPC.setup!-Tuple{LinearMPC.MPC}","page":"Functions","title":"LinearMPC.setup!","text":"setup!(mpc)\n\nSets up the mpc given its current parameters and settings   Internally, this means generating an mpQP, and setting up a DAQP workspace.\n\n\n\n\n\n","category":"method"},{"location":"manual/explicit/#man_empc","page":"Explict MPC","title":"Explicit MPC","text":"","category":"section"},{"location":"manual/explicit/","page":"Explict MPC","title":"Explict MPC","text":"Concept of explicit MPC\nThe solver (ParametricDAQP.jl)\nComputing explicit solution \nParameterRange\nVisualizing Explicit Solution \nGenerating code","category":"page"},{"location":"manual/compcert/#man_compcert","page":"Complexity Certification","title":"Complexity Certification","text":"","category":"section"},{"location":"manual/compcert/","page":"Complexity Certification","title":"Complexity Certification","text":"Real-time MPC\nIdea of mapping\nHow to call certification\nInterpreting result ","category":"page"},{"location":"manual/simulation/#man_simulation","page":"Simulating","title":"Simulating","text":"","category":"section"},{"location":"manual/simulation/","page":"Simulating","title":"Simulating","text":"Simulation class \nRunning simulation\nVisualizing\nCallback","category":"page"},{"location":"manual/model/#man_model","page":"Models","title":"Models","text":"","category":"section"},{"location":"manual/model/","page":"Models","title":"Models","text":"Continuous-time\nDiscrete-time\nControl Systems\nLinearization","category":"page"},{"location":"manual/solver/#man_solver","page":"Solver Settings","title":"Solver Settings","text":"","category":"section"},{"location":"manual/solver/","page":"Solver Settings","title":"Solver Settings","text":"Generated code\nPrecision\nTolerances\nIteration limits","category":"page"},{"location":"manual/simple/#man_simple","page":"Simple Example","title":"Simple Example","text":"","category":"section"},{"location":"manual/simple/","page":"Simple Example","title":"Simple Example","text":"Inverted pendulum example","category":"page"},{"location":"manual/objective/#man_objective","page":"Objective Functions","title":"Objective","text":"","category":"section"},{"location":"manual/objective/","page":"Objective Functions","title":"Objective Functions","text":"State/reference tracking\nControl weights\nRate weights\nCross-term \nSoft constraints ","category":"page"},{"location":"manual/constraints/#man_constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Bounds on control\nBounds on output\nGeneral constraints \nSoft\nBinary\nPriority","category":"page"},{"location":"#LinearMPC.jl","page":"Home","title":"LinearMPC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Documentation under development\nThe documentation for LineaerMPC.jl is currently under development","category":"page"},{"location":"","page":"Home","title":"Home","text":"The focus of LinearMPC.jl is Model Predictive Control (MPC) of linear systems. The aim of the package is to produce high-performant and lightweight C-code that can easily be used on embedded systems, while at the same time give a user-friendly and expressive development environment for MPC. The package supports code generation for the Quadratic Programming solver DAQP, and for explicit solutions computed by ParametricDAQP.jl.","category":"page"},{"location":"#Model-Predictive-Control","page":"Home","title":"Model Predictive Control","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In MPC, an optimal control decision is computed at every sampling instance by solving an optimization probelm. On a high-level, the optimization problems solved are of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\n        undersetu_0dotsu_N-1textminimize textcolorpurplefrac12sum_k=0^N-1 left((Cx_k-r)^T Q (C x_k-r) + u_k^T R u_k + Delta u_k^T R_r Delta u_kright)\n        textsubject to textcolorbluex_k+1 = F x_k + G u_k quad k=0dots N-1\n         textcolorredx_0 = hatx \n         textcolorgreenunderlineb leq A_x x_k + A_u u_k  leq overlineb quad k=0 dots N-1\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where an textcolorpurpletextobjective is minimized , subject to a textcolorbluetextdynamical system that is simulated over a horizon N, textcolorredtextstarting from an estimate hatx of the current state. Additionally, textcolorgreentextconstraints like actuator limits and state constraints are accounted for. The objective is comprised by the deviation of an output y= Cx from a reference value r, the control effort (u^T R u) , and the change of the control action Delta u^T R_r Delta u. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"LinearMPC.jl generates a condensed problem by eliminating the equality constraint. The resuliting optimization problem is a dense Quadratic Program (QP). LinearMPC.jl uses the QP sovler DAQP, a dual active-set solver that has been specialized to solved such problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The solution map for the optimization problem is a piecewise affine function over polyhedral regions. LinearMPC.jl supports the computation of such explicit solutions by interfacing the multi-parameteric QP solver ParametricDAQP.jl","category":"page"},{"location":"#Why-LinearMPC.jl?","page":"Home","title":"Why LinearMPC.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Code generation of high-performant, allocation-free, library-free, and lightweight C-code that can be embedded on any micro controller. \nState-of-the-art computation of explicit solutions (~100x faster than other software packages)  \nTools to determine real-time certificates of the complexity of the solver, allowing for MPC in with guarantees on the memory and computationala requirements before deploying the solver.","category":"page"},{"location":"#Why-not-LinearMPC.jl?","page":"Home","title":"Why not LinearMPC.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As its name suggests, the package is specialized for MPC for linear systems. If a linear (or linearized) model does not suffices for your use case, consider the following packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelPredictiveControl.jl - A high-level MPC packages in Julia. While it does not generate embeddable C-code, it is an excellent package during development of MPC controllers. \nacados - provides fast and embedded solvers for nonlinear optimal control, specifically designed for real-time applications and embedded systems. This is the current state-of-the art if you are interested in real-time nonlinear MPC on embedded systems. \nAre you more of a Python person? You can still use LinearMPC.jl through its sister package lmpc.","category":"page"}]
}
